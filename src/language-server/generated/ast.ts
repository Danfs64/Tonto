/******************************************************************************
 * This file was generated by langium-cli 0.2.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable @typescript-eslint/array-type */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { AstNode, AstReflection, Reference, isAstNode } from 'langium';

export interface ClassPrefix extends AstNode {
    readonly $container: Element;
    stereotype: Stereotype
}

export const ClassPrefix = 'ClassPrefix';

export function isClassPrefix(item: unknown): item is ClassPrefix {
    return reflection.isInstance(item, ClassPrefix);
}

export interface ContextModule extends AstNode {
    readonly $container: ModelElement;
    elements: Array<Element>
    name: QualifiedName
}

export const ContextModule = 'ContextModule';

export function isContextModule(item: unknown): item is ContextModule {
    return reflection.isInstance(item, ContextModule);
}

export interface Element extends AstNode {
    readonly $container: ContextModule;
    name: string
    prefix: ClassPrefix
}

export const Element = 'Element';

export function isElement(item: unknown): item is Element {
    return reflection.isInstance(item, Element);
}

export interface EndurantReference extends AstNode {
    readonly $container: Class | Relator;
    referencedClass: Reference<Class>
    refName: string
}

export const EndurantReference = 'EndurantReference';

export function isEndurantReference(item: unknown): item is EndurantReference {
    return reflection.isInstance(item, EndurantReference);
}

export interface Model extends AstNode {
    elements: Array<ModelElement>
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface ModelElement extends AstNode {
    readonly $container: Model;
    module: ContextModule
}

export const ModelElement = 'ModelElement';

export function isModelElement(item: unknown): item is ModelElement {
    return reflection.isInstance(item, ModelElement);
}

export interface Stereotype extends AstNode {
    readonly $container: ClassPrefix;
    stereotype: string
}

export const Stereotype = 'Stereotype';

export function isStereotype(item: unknown): item is Stereotype {
    return reflection.isInstance(item, Stereotype);
}

export interface Class extends Element {
    references: EndurantReference
    specializationClass?: Reference<Class>
}

export const Class = 'Class';

export function isClass(item: unknown): item is Class {
    return reflection.isInstance(item, Class);
}

export interface Endurant extends Element {
    specializationEndurant?: Reference<Endurant>
    type: EndurantType
}

export const Endurant = 'Endurant';

export function isEndurant(item: unknown): item is Endurant {
    return reflection.isInstance(item, Endurant);
}

export interface Relator extends Element {
    references: EndurantReference
}

export const Relator = 'Relator';

export function isRelator(item: unknown): item is Relator {
    return reflection.isInstance(item, Relator);
}

export type QualifiedName = string

export type EndurantType = 'kind' | 'subkind' | 'collective' | 'phase' | 'role' | 'category' | 'roleMixin' | 'mode' | 'quality'

export type TontoAstType = 'ClassPrefix' | 'ContextModule' | 'Element' | 'EndurantReference' | 'Model' | 'ModelElement' | 'Stereotype' | 'Class' | 'Endurant' | 'Relator';

export type TontoAstReference = 'EndurantReference:referencedClass' | 'Class:specializationClass' | 'Endurant:specializationEndurant';

export class TontoAstReflection implements AstReflection {

    getAllTypes(): string[] {
        return ['ClassPrefix', 'ContextModule', 'Element', 'EndurantReference', 'Model', 'ModelElement', 'Stereotype', 'Class', 'Endurant', 'Relator'];
    }

    isInstance(node: unknown, type: string): boolean {
        return isAstNode(node) && this.isSubtype(node.$type, type);
    }

    isSubtype(subtype: string, supertype: string): boolean {
        if (subtype === supertype) {
            return true;
        }
        switch (subtype) {
            case Class:
            case Endurant:
            case Relator: {
                return this.isSubtype(Element, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(referenceId: TontoAstReference): string {
        switch (referenceId) {
            case 'EndurantReference:referencedClass': {
                return Class;
            }
            case 'Class:specializationClass': {
                return Class;
            }
            case 'Endurant:specializationEndurant': {
                return Endurant;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }
}

export const reflection = new TontoAstReflection();
