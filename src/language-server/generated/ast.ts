/******************************************************************************
 * This file was generated by langium-cli 0.3.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable @typescript-eslint/array-type */
/* eslint-disable @typescript-eslint/no-empty-interface */
import { AstNode, AstReflection, Reference, isAstNode } from 'langium';

export type AuxiliaryDeclarations = DataType | EndurantExternalReference | EnumData | GeneralizationSet;

export const AuxiliaryDeclarations = 'AuxiliaryDeclarations';

export function isAuxiliaryDeclarations(item: unknown): item is AuxiliaryDeclarations {
    return reflection.isInstance(item, AuxiliaryDeclarations);
}

export type BaseSortalStereotype = 'historicalrole' | 'phase' | 'relator' | 'role' | 'subkind';

export type NonSortalStereotype = 'category' | 'event' | 'historicalrolemixin' | 'mixin' | 'phasemixin' | 'rolemixin';

export type QualifiedName = string;

export type ReferenceConnector = '--' | '<>--';

export type RelationStereotype = 'aggregation' | 'bringsAbout' | 'characterization' | 'comparative' | 'componentOf' | 'composition' | 'creation' | 'derivation' | 'externalDependence' | 'historicalDependence' | 'instantiation' | 'manifestation' | 'material' | 'mediation' | 'memberOf' | 'participation' | 'participational' | 'relator' | 'subCollectionOf' | 'subQuantityOf' | 'termination' | 'triggers';

export type UltimateSortalStereotypes = 'collective' | 'kind' | 'mode' | 'quality' | 'quantity';

export interface Cardinality extends AstNode {
    lowerBound: '*' | number
    upperBound: '*' | number
}

export const Cardinality = 'Cardinality';

export function isCardinality(item: unknown): item is Cardinality {
    return reflection.isInstance(item, Cardinality);
}

export interface ClassPrefix extends AstNode {
    readonly $container: Element;
    stereotype: Stereotype
}

export const ClassPrefix = 'ClassPrefix';

export function isClassPrefix(item: unknown): item is ClassPrefix {
    return reflection.isInstance(item, ClassPrefix);
}

export interface ContextModule extends AstNode {
    readonly $container: Model;
    elements: Array<Element>
    name: QualifiedName
}

export const ContextModule = 'ContextModule';

export function isContextModule(item: unknown): item is ContextModule {
    return reflection.isInstance(item, ContextModule);
}

export interface DataType extends AstNode {
    readonly $container: ContextModule | EndurantExternalReference;
    name: string
    properties: DataTypeProperty
}

export const DataType = 'DataType';

export function isDataType(item: unknown): item is DataType {
    return reflection.isInstance(item, DataType);
}

export interface DataTypeProperty extends AstNode {
    readonly $container: DataType;
    name: string
    type: Reference<DataType>
}

export const DataTypeProperty = 'DataTypeProperty';

export function isDataTypeProperty(item: unknown): item is DataTypeProperty {
    return reflection.isInstance(item, DataTypeProperty);
}

export interface Element extends AstNode {
    readonly $container: ContextModule | EndurantExternalReference;
    name: QualifiedName
    prefix: ClassPrefix
    specializationClasses: Array<Reference<Element>>
    specializationEndurants: Array<Reference<Element>>
    type: EndurantType
}

export const Element = 'Element';

export function isElement(item: unknown): item is Element {
    return reflection.isInstance(item, Element);
}

export interface EndurantExternalReference extends AstNode {
    readonly $container: ContextModule | EndurantExternalReference;
    firstEnd: EndurantExternalReference
    name: string
    secondEnd: Reference<Element>
}

export const EndurantExternalReference = 'EndurantExternalReference';

export function isEndurantExternalReference(item: unknown): item is EndurantExternalReference {
    return reflection.isInstance(item, EndurantExternalReference);
}

export interface EndurantType extends AstNode {
    readonly $container: Element;
    stereotype: BaseSortalStereotype | NonSortalStereotype | UltimateSortalStereotypes
}

export const EndurantType = 'EndurantType';

export function isEndurantType(item: unknown): item is EndurantType {
    return reflection.isInstance(item, EndurantType);
}

export interface EnumData extends AstNode {
    readonly $container: ContextModule | EndurantExternalReference;
    elements: Array<EnumElement>
    name: string
}

export const EnumData = 'EnumData';

export function isEnumData(item: unknown): item is EnumData {
    return reflection.isInstance(item, EnumData);
}

export interface EnumElement extends AstNode {
    readonly $container: EnumData;
    name: string
}

export const EnumElement = 'EnumElement';

export function isEnumElement(item: unknown): item is EnumElement {
    return reflection.isInstance(item, EnumElement);
}

export interface GeneralizationSet extends AstNode {
    readonly $container: ContextModule | EndurantExternalReference;
    categorizerItems: Array<Reference<Element>>
    complete: 'complete'
    disjoint: 'disjoint'
    generalItem: Array<Reference<Element>>
    name: string
    specificItems: Array<Reference<Element>>
}

export const GeneralizationSet = 'GeneralizationSet';

export function isGeneralizationSet(item: unknown): item is GeneralizationSet {
    return reflection.isInstance(item, GeneralizationSet);
}

export interface Model extends AstNode {
    elements: Array<ContextModule>
}

export const Model = 'Model';

export function isModel(item: unknown): item is Model {
    return reflection.isInstance(item, Model);
}

export interface ReferenceFirstExpression extends AstNode {
    firstEnd: Reference<Element>
}

export const ReferenceFirstExpression = 'ReferenceFirstExpression';

export function isReferenceFirstExpression(item: unknown): item is ReferenceFirstExpression {
    return reflection.isInstance(item, ReferenceFirstExpression);
}

export interface RelationDescription extends AstNode {
    name: string
}

export const RelationDescription = 'RelationDescription';

export function isRelationDescription(item: unknown): item is RelationDescription {
    return reflection.isInstance(item, RelationDescription);
}

export interface Stereotype extends AstNode {
    readonly $container: ClassPrefix;
    stereotype: 'abstract' | 'category' | 'collective' | 'enumeration' | 'event' | 'historicalRole' | 'historicalRoleMixin' | 'kind' | 'mixin' | 'mode' | 'phase' | 'phaseMixin' | 'quality' | 'quantity' | 'relator' | 'role' | 'roleMixin' | 'situation' | 'subkind' | 'type'
}

export const Stereotype = 'Stereotype';

export function isStereotype(item: unknown): item is Stereotype {
    return reflection.isInstance(item, Stereotype);
}

export type tontoAstType = 'AuxiliaryDeclarations' | 'Cardinality' | 'ClassPrefix' | 'ContextModule' | 'DataType' | 'DataTypeProperty' | 'Element' | 'EndurantExternalReference' | 'EndurantType' | 'EnumData' | 'EnumElement' | 'GeneralizationSet' | 'Model' | 'ReferenceFirstExpression' | 'RelationDescription' | 'Stereotype';

export type tontoAstReference = 'DataTypeProperty:type' | 'Element:specializationClasses' | 'Element:specializationEndurants' | 'EndurantExternalReference:secondEnd' | 'GeneralizationSet:categorizerItems' | 'GeneralizationSet:generalItem' | 'GeneralizationSet:specificItems' | 'ReferenceFirstExpression:firstEnd';

export class tontoAstReflection implements AstReflection {

    getAllTypes(): string[] {
        return ['AuxiliaryDeclarations', 'Cardinality', 'ClassPrefix', 'ContextModule', 'DataType', 'DataTypeProperty', 'Element', 'EndurantExternalReference', 'EndurantType', 'EnumData', 'EnumElement', 'GeneralizationSet', 'Model', 'ReferenceFirstExpression', 'RelationDescription', 'Stereotype'];
    }

    isInstance(node: unknown, type: string): boolean {
        return isAstNode(node) && this.isSubtype(node.$type, type);
    }

    isSubtype(subtype: string, supertype: string): boolean {
        if (subtype === supertype) {
            return true;
        }
        switch (subtype) {
            case DataType:
            case EndurantExternalReference:
            case EnumData:
            case GeneralizationSet: {
                return this.isSubtype(AuxiliaryDeclarations, supertype);
            }
            case AuxiliaryDeclarations: {
                return this.isSubtype(Element, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(referenceId: tontoAstReference): string {
        switch (referenceId) {
            case 'DataTypeProperty:type': {
                return DataType;
            }
            case 'Element:specializationClasses': {
                return Element;
            }
            case 'Element:specializationEndurants': {
                return Element;
            }
            case 'EndurantExternalReference:secondEnd': {
                return Element;
            }
            case 'GeneralizationSet:categorizerItems': {
                return Element;
            }
            case 'GeneralizationSet:generalItem': {
                return Element;
            }
            case 'GeneralizationSet:specificItems': {
                return Element;
            }
            case 'ReferenceFirstExpression:firstEnd': {
                return Element;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }
}

export const reflection = new tontoAstReflection();
